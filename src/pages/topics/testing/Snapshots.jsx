import React from "react";
import { Styled } from "./styled";

const Snapshots = () => {
    return (
        <Styled.Page>
            <Styled.Title>Snapshots</Styled.Title>

            <Styled.Lead>
                <b>Snapshot testing</b> saves a “frozen” copy of a component's rendered output (or any
                serializable value) and compares future test runs against it. If the output changes, the test
                fails—prompting you to review whether the change was intentional.
            </Styled.Lead>

            {/* 1) Definitions */}
            <Styled.Section>
                <Styled.H2>Key Definitions</Styled.H2>
                <Styled.List>
                    <li>
                        <b>Snapshot:</b> A stored text representation of a value (often DOM markup) used for
                        future comparisons.
                    </li>
                    <li>
                        <b>Snapshot file:</b> A <Styled.InlineCode>__snapshots__</Styled.InlineCode> folder
                        contains <Styled.InlineCode>.snap</Styled.InlineCode> files auto-generated by Jest when
                        using <Styled.InlineCode>toMatchSnapshot()</Styled.InlineCode>.
                    </li>
                    <li>
                        <b>Inline snapshot:</b> A snapshot string kept <i>inside</i> your test file using{" "}
                        <Styled.InlineCode>toMatchInlineSnapshot()</Styled.InlineCode>.
                    </li>
                    <li>
                        <b>Serializer:</b> A function that tells Jest how to print/format complex values in
                        snapshots (e.g., tidy React DOM, strip noise).
                    </li>
                    <li>
                        <b>Deterministic test:</b> A test whose output doesn't change randomly between runs
                        (e.g., you've mocked time/randomness).
                    </li>
                </Styled.List>
            </Styled.Section>

            {/* 2) When (and when not) to use snapshots */}
            <Styled.Section>
                <Styled.H2>When (and When Not) to Use Snapshots</Styled.H2>
                <Styled.List>
                    <li>
                        <b>Good for:</b> small, stable UI fragments; utility output; serialized configs; public
                        component API contracts.
                    </li>
                    <li>
                        <b>Avoid:</b> snapshotting huge, dynamic trees (too noisy/brittle). Prefer explicit
                        assertions (e.g., “button is disabled,” “alert text is shown”).
                    </li>
                    <li>
                        <b>Team rule of thumb:</b> a snapshot diff should be easy for a reviewer to scan and
                        understand. If not, prefer targeted assertions.
                    </li>
                </Styled.List>
            </Styled.Section>

            {/* 3) Basic example with React Testing Library */}
            <Styled.Section>
                <Styled.H2>Basic Example (React Testing Library)</Styled.H2>
                <Styled.Pre>
                    {`// __tests__/Card.test.jsx
import { render } from "@testing-library/react";
import Card from "../Card";

test("Card snapshot", () => {
  const { container } = render(<Card title="Hello" count={3} />);
  // container.firstChild is the root DOM node of <Card />
  expect(container.firstChild).toMatchSnapshot();
});`}
                </Styled.Pre>
                <Styled.Small>
                    First run creates a <Styled.InlineCode>.snap</Styled.InlineCode>. Subsequent runs must
                    match—otherwise the test fails with a readable diff.
                </Styled.Small>
            </Styled.Section>

            {/* 4) Inline snapshots */}
            <Styled.Section>
                <Styled.H2>Inline Snapshots</Styled.H2>
                <Styled.Pre>
                    {`// Prefer inline snapshots for tiny, stable outputs
import { render } from "@testing-library/react";
import Badge from "../Badge";

test("Badge inline snapshot", () => {
  const { container } = render(<Badge variant="success">OK</Badge>);
  expect(container.firstChild).toMatchInlineSnapshot(\`
<span class="badge badge-success">
  OK
</span>
\`);
});`}
                </Styled.Pre>
                <Styled.Small>
                    Inline snapshots keep expectation and stored value side-by-side—great for review.
                </Styled.Small>
            </Styled.Section>

            {/* 5) Updating snapshots */}
            <Styled.Section>
                <Styled.H2>Updating Snapshots</Styled.H2>
                <Styled.List>
                    <li>
                        If a change is <b>intentional</b>, update snapshots via{" "}
                        <Styled.InlineCode>jest -u</Styled.InlineCode> (or in watch mode press{" "}
                        <Styled.InlineCode>u</Styled.InlineCode>).
                    </li>
                    <li>
                        Review diffs carefully. <b>Never</b> update snapshots just to “make tests pass” without
                        understanding the change.
                    </li>
                    <li>
                        In CI, keep snapshots committed to the repo so teammates see diffs in PRs.
                    </li>
                </Styled.List>
            </Styled.Section>

            {/* 6) Serializers to reduce noise */}
            <Styled.Section>
                <Styled.H2>Using Serializers (Reduce Noise)</Styled.H2>
                <Styled.Pre>
                    {`// jest.setup.js
import serializer from "jest-serializer-html"; // example serializer
expect.addSnapshotSerializer(serializer);

// Or write your own:
expect.addSnapshotSerializer({
  test: (val) => typeof val === "string" && val.startsWith("<"),
  print: (val, serialize) => serialize(val.replace(/\\s+data-[^=]+="[^"]*"/g, "")), // strip data-attrs
});`}
                </Styled.Pre>
                <Styled.Small>
                    Serializers make snapshots cleaner by removing unstable attributes (e.g., random IDs).
                </Styled.Small>
            </Styled.Section>

            {/* 7) Making tests deterministic */}
            <Styled.Section>
                <Styled.H2>Make Snapshots Deterministic</Styled.H2>
                <Styled.List>
                    <li>
                        <b>Mock time:</b>{" "}
                        <Styled.InlineCode>jest.useFakeTimers(); jest.setSystemTime(new Date("2025-01-01"));</Styled.InlineCode>
                    </li>
                    <li>
                        <b>Mock randomness:</b>{" "}
                        <Styled.InlineCode>jest.spyOn(Math, "random").mockReturnValue(0.1234);</Styled.InlineCode>
                    </li>
                    <li>
                        <b>Mock environment:</b> isolate locale/timezone if output depends on them.
                    </li>
                </Styled.List>
                <Styled.Pre>
                    {`beforeAll(() => {
  jest.useFakeTimers();
  jest.setSystemTime(new Date("2025-01-01T00:00:00Z"));
  jest.spyOn(Math, "random").mockReturnValue(0.5);
});
afterAll(() => {
  jest.useRealTimers();
  jest.restoreAllMocks();
});`}
                </Styled.Pre>
            </Styled.Section>

            {/* 8) Alternatives & complements */}
            <Styled.Section>
                <Styled.H2>Alternatives & Complements</Styled.H2>
                <Styled.List>
                    <li>
                        <b>Explicit assertions:</b> Use{" "}
                        <Styled.InlineCode>@testing-library/jest-dom</Styled.InlineCode> matchers (e.g.,
                        <Styled.InlineCode>toBeDisabled</Styled.InlineCode>,{" "}
                        <Styled.InlineCode>toHaveTextContent</Styled.InlineCode>).
                    </li>
                    <li>
                        <b>Visual regression:</b> Tools like Percy/Chromatic take <i>pixel</i> snapshots across
                        browsers—stronger for CSS/layout changes.
                    </li>
                    <li>
                        <b>Story-based tests:</b> Snapshot the output of small, stateless stories instead of full app pages.
                    </li>
                </Styled.List>
            </Styled.Section>

            {/* 9) Do / Don't */}
            <Styled.Section>
                <Styled.H2>Do &amp; Don't</Styled.H2>
                <Styled.List>
                    <li><b>Do</b> snapshot small, stable pieces of UI.</li>
                    <li><b>Do</b> keep snapshots readable (use serializers; avoid noise).</li>
                    <li><b>Do</b> review diffs like production code.</li>
                    <li><b>Don't</b> snapshot entire pages or constantly changing DOM.</li>
                    <li><b>Don't</b> treat snapshot updates as routine; understand the change first.</li>
                </Styled.List>
            </Styled.Section>

            {/* 10) Glossary */}
            <Styled.Section>
                <Styled.H2>Glossary</Styled.H2>
                <Styled.List>
                    <li>
                        <b>toMatchSnapshot:</b> Jest matcher that writes/compares a value to a snapshot file.
                    </li>
                    <li>
                        <b>toMatchInlineSnapshot:</b> Stores the snapshot string directly in the test source.
                    </li>
                    <li>
                        <b>Serializer:</b> Custom printer that controls how values appear in snapshots.
                    </li>
                    <li>
                        <b>Diff:</b> The line-by-line change Jest shows when a snapshot no longer matches.
                    </li>
                </Styled.List>
            </Styled.Section>

            <Styled.Callout>
                Snapshot testing is great for catching unexpected changes in small, stable outputs. Keep
                snapshots tidy and deterministic, prefer explicit assertions for behavior, and review diffs
                with the same care as production code.
            </Styled.Callout>
        </Styled.Page>
    );
};

export default Snapshots;
