import{j as e}from"./index-CEhT6f_w.js";import{S as s}from"./styled-8xVinwqO.js";const r=()=>e.jsxs(s.Page,{children:[e.jsx(s.Title,{children:"Auth Basics"}),e.jsxs(s.Lead,{children:[e.jsx("b",{children:"Authentication"})," proves ",e.jsx("i",{children:"who you are"}),". ",e.jsx("b",{children:"Authorization"})," decides ",e.jsx("i",{children:"what you can do"}),". Web apps implement auth using ",e.jsx("b",{children:"sessions"})," (cookies) or ",e.jsx("b",{children:"tokens"})," (e.g., JWT). Understanding the terms and the common flows helps you choose safe defaults for React SPAs."]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Core Definitions"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Identity:"})," who the user is (e.g., user id/email)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Credential:"})," a secret used to prove identity (password, OTP, passkey, OAuth grant)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Authentication:"})," verifying credentials; result is a trusted session or token."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Authorization:"})," allowing/denying actions/resources after auth (roles, permissions, scopes)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Session:"})," server-side record of a logged-in user; client holds only a session ",e.jsx("i",{children:"id"})," cookie."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Token:"})," self-contained or opaque string the client presents on each request (e.g., in ",e.jsx(s.InlineCode,{children:"Authorization: Bearer"}),")."]}),e.jsxs("li",{children:[e.jsx("b",{children:"JWT (JSON Web Token):"})," signed, base64url-encoded claims (e.g., ",e.jsx(s.InlineCode,{children:"sub"}),", ",e.jsx(s.InlineCode,{children:"exp"}),", roles)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Access token:"})," short-lived token used to access APIs."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Refresh token:"})," longer-lived credential used to obtain new access tokens."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Cookie:"})," small key/value stored by the browser; may be ",e.jsx("b",{children:"HttpOnly"})," (not readable by JS) and ",e.jsx("b",{children:"Secure"})," (HTTPS only)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"SameSite:"})," cookie rule controlling cross-site sending: ",e.jsx("b",{children:"Lax"})," (default), ",e.jsx("b",{children:"Strict"}),", or ",e.jsx("b",{children:"None"})," (requires Secure)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"CSRF:"})," Cross-Site Request Forgery—an attacker makes the browser send your cookies to a site."]}),e.jsxs("li",{children:[e.jsx("b",{children:"XSS:"})," Cross-Site Scripting—attacker runs arbitrary JS in your page context."]}),e.jsxs("li",{children:[e.jsx("b",{children:"OAuth 2.0:"})," framework to obtain access tokens (delegated access)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"OIDC (OpenID Connect):"})," identity layer on top of OAuth that adds login/user info."]}),e.jsxs("li",{children:[e.jsx("b",{children:"PKCE:"})," Proof Key for Code Exchange—secures OAuth ",e.jsx("i",{children:"Authorization Code"})," flow in public clients (SPAs)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Scopes:"})," strings describing allowed actions (“read:invoices”)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Claims:"})," data inside tokens (e.g., user id, expiry, roles)."]})]})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Two Common Auth Models"}),e.jsx(s.H3,{children:"1) Server Session (Cookie)"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:["Server verifies login → creates a session in DB/Redis → sets a ",e.jsx("b",{children:"session id cookie"})," (",e.jsx(s.InlineCode,{children:"HttpOnly; Secure; SameSite=Lax"}),")."]}),e.jsx("li",{children:"Browser auto-sends cookie; server looks up the session and authorizes."}),e.jsxs("li",{children:[e.jsx("b",{children:"Pros:"})," simple to reason about, easy rotation, ",e.jsx("b",{children:"HttpOnly"})," cookies mitigate XSS token theft."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Cons:"})," must design to prevent CSRF (use SameSite, CSRF tokens, double submit, etc.)."]})]}),e.jsx(s.H3,{children:"2) Token-Based (JWT / Opaque)"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:["Server/IdP issues ",e.jsx("b",{children:"access"})," (short-lived) and optionally ",e.jsx("b",{children:"refresh"})," tokens."]}),e.jsxs("li",{children:["Client sends ",e.jsx(s.InlineCode,{children:"Authorization: Bearer <access_token>"})," to APIs."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Pros:"})," easy API fan-out, stateless access tokens."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Cons:"})," where to store tokens? XSS can steal tokens from JS-readable storage; refresh flows add complexity."]})]})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Recommended SPA Patterns"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Auth Code + PKCE (with OIDC):"})," SPA redirects to provider; receives an authorization code; exchanges it (with PKCE) for tokens."]}),e.jsxs("li",{children:[e.jsx("b",{children:"BFF pattern:"})," a small backend-for-frontend holds tokens/cookies; SPA talks only to the BFF. Reduces token exposure to the browser."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Short-lived access tokens in memory:"})," keep access token only in memory; use a ",e.jsx("b",{children:"HttpOnly refresh token cookie"})," or refresh endpoint behind BFF."]}),e.jsxs("li",{children:[e.jsx("b",{children:"SameSite and CSRF:"})," if using cookies to auth APIs, use ",e.jsx(s.InlineCode,{children:"SameSite=Lax/Strict"})," and a CSRF token for state-changing requests."]})]}),e.jsx(s.Pre,{children:`// Minimal shape for an in-memory access token approach (client):
const auth = {
  accessToken: null,          // never store in localStorage if you can avoid it
  async login(creds) {
    // POST /auth/login returns { accessToken } and sets a refresh cookie (HttpOnly, SameSite=Lax)
    const res = await fetch("/auth/login", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      credentials: "include", // send/receive cookies
      body: JSON.stringify(creds),
    });
    const data = await res.json();
    this.accessToken = data.accessToken; // keep in memory only
  },
  async fetchWithAuth(input, init = {}) {
    const res = await fetch(input, {
      ...init,
      headers: { ...(init.headers || {}), Authorization: \`Bearer \${this.accessToken}\` },
      credentials: "include",
    });
    if (res.status === 401) {
      // Try to refresh (server looks up refresh cookie & rotates)
      const r = await fetch("/auth/refresh", { method: "POST", credentials: "include" });
      if (r.ok) {
        const { accessToken } = await r.json();
        this.accessToken = accessToken;
        return this.fetchWithAuth(input, init); // retry once
      }
    }
    return res;
  },
};`}),e.jsxs(s.Small,{children:[e.jsx("b",{children:"Note:"})," This is conceptual. Real apps add error handling, retries, logout, and revoke/rotate refresh tokens."]})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Where to Store Tokens?"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Memory:"})," safest against persistent XSS (disappears on reload). ",e.jsx("i",{children:"Recommended"})," for access tokens."]}),e.jsxs("li",{children:[e.jsx("b",{children:"HttpOnly Cookie:"})," not readable by JS; good for session ids and refresh tokens. Configure ",e.jsx(s.InlineCode,{children:"Secure"})," + ",e.jsx(s.InlineCode,{children:"SameSite"}),"."]}),e.jsxs("li",{children:[e.jsx("b",{children:"localStorage/sessionStorage:"})," easy but vulnerable to XSS token theft. Avoid for long-lived secrets."]}),e.jsxs("li",{children:[e.jsx("b",{children:"IndexedDB:"})," slightly better ergonomics than localStorage but still JS-readable → XSS risk persists."]})]}),e.jsxs(s.Callout,{children:["Rule of thumb: ",e.jsx("b",{children:"Access token in memory"}),", ",e.jsx("b",{children:"refresh token in HttpOnly cookie"}),", or use a ",e.jsx("b",{children:"BFF"}),"."]})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"CSRF vs XSS: What to Watch"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"CSRF (cookie-backed APIs):"})," protect with ",e.jsx(s.InlineCode,{children:"SameSite"}),", CSRF tokens (per form/request), and check ",e.jsx(s.InlineCode,{children:"Origin/Referer"})," on the server."]}),e.jsxs("li",{children:[e.jsx("b",{children:"XSS (token theft):"})," sanitize/escape user content, use CSP, avoid ",e.jsx(s.InlineCode,{children:"dangerouslySetInnerHTML"}),", and never eval untrusted code."]}),e.jsxs("li",{children:[e.jsx("b",{children:"JWT misuse:"})," don't trust client claims; always verify signature and ",e.jsx(s.InlineCode,{children:"exp"}),"/",e.jsx(s.InlineCode,{children:"aud"}),"/",e.jsx(s.InlineCode,{children:"iss"})," server-side."]})]})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Guarded Routes (Client-Side)"}),e.jsx(s.Pre,{children:`// Conceptual PrivateRoute (React Router v6)
import { Navigate, Outlet, useLocation } from "react-router-dom";
function PrivateRoute({ isAuthed }) {
  const location = useLocation();
  return isAuthed ? <Outlet /> : <Navigate to="/login" replace state={{ from: location }} />;
}

// Usage in routes:
// <Route element={<PrivateRoute isAuthed={auth.isLoggedIn} />}>
//   <Route path="/dashboard" element={<Dashboard />} />
// </Route>

// IMPORTANT: Client guards are UX only.
// Real protection must happen on the SERVER (verify session/token on every request).`})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Login & Logout (Cookie Session Example)"}),e.jsx(s.Pre,{children:`// Login (server will set HttpOnly session cookie)
await fetch("/auth/session/login", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  credentials: "include",
  body: JSON.stringify({ email, password }),
});

// Authenticated API call (cookie auto-sent)
await fetch("/api/profile", { credentials: "include" });

// Logout (server clears session & cookie)
await fetch("/auth/session/logout", { method: "POST", credentials: "include" });`}),e.jsx(s.Small,{children:"With cookies, the browser handles sending credentials; ensure CORS and cookie flags are configured properly."})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"CORS + Cookies (Quick Rules)"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:["Set ",e.jsxs(s.InlineCode,{children:["fetch(..., ",'{ credentials: "include" }',")"]})," to send cookies cross-site."]}),e.jsxs("li",{children:["Server must set ",e.jsx(s.InlineCode,{children:"Access-Control-Allow-Credentials: true"})," and a specific ",e.jsx(s.InlineCode,{children:"Access-Control-Allow-Origin"})," (not ",e.jsx("i",{children:"*"}),")."]}),e.jsxs("li",{children:["Set cookies with ",e.jsx(s.InlineCode,{children:"Secure; HttpOnly; SameSite=Lax"})," (or ",e.jsx(s.InlineCode,{children:"None"})," + ",e.jsx(s.InlineCode,{children:"Secure"})," for third-party)."]})]})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Password & Account Safety"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Hash passwords"})," with modern algorithms (bcrypt/argon2) and a per-user salt; never store plaintext."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Rate limit"})," login and sensitive endpoints; implement lockout/captcha after repeated failures."]}),e.jsxs("li",{children:[e.jsx("b",{children:"MFA/2FA"})," (TOTP, WebAuthn/passkeys) to harden high-value accounts."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Session fixation:"})," issue a fresh session id after login."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Logout everywhere:"})," support session/token revocation."]})]})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Do & Don't"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Do"})," keep access tokens short-lived; refresh/rotate securely."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Do"})," validate tokens server-side (sig + expiry + audience/issuer)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Do"})," use ",e.jsx("b",{children:"HttpOnly Secure"})," cookies (SameSite set) or BFF pattern."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Don't"})," store long-lived tokens in ",e.jsx(s.InlineCode,{children:"localStorage"}),"."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Don't"})," trust client-side route guards for security; always enforce on the server."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Don't"})," put secrets in front-end env files—they ship to the browser."]})]})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Glossary"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"BFF:"})," Backend-for-Frontend—a small server that fronts APIs and manages auth on behalf of the SPA."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Nonce:"})," random value used to bind OIDC id_token to the auth request, preventing replay/mix-up."]}),e.jsxs("li",{children:[e.jsx("b",{children:"State (OAuth):"})," random string to tie the callback to the initiation request (CSRF protection)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Opaque token:"})," a random string that the server introspects instead of reading claims client-side."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Introspection:"})," server endpoint that validates an opaque token and returns its active/claims data."]}),e.jsxs("li",{children:[e.jsx("b",{children:"CSP:"})," Content Security Policy—HTTP header restricting sources of scripts/styles to mitigate XSS."]})]})]}),e.jsxs(s.Callout,{children:[e.jsx("b",{children:"Bottom line:"})," Prefer ",e.jsx("i",{children:"short-lived access tokens in memory"})," with ",e.jsx("i",{children:"refresh via HttpOnly cookie"})," or a ",e.jsx("i",{children:"BFF"}),". Always verify auth on the server, and harden against both ",e.jsx("b",{children:"XSS"})," and ",e.jsx("b",{children:"CSRF"}),"."]})]});export{r as default};
