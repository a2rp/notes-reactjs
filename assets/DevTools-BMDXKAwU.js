import{j as e}from"./index-t22nWg0v.js";import{S as n}from"./styled-fXjr1UBq.js";const o=()=>e.jsxs(n.Page,{children:[e.jsx(n.Title,{children:"React DevTools"}),e.jsxs(n.Lead,{children:[e.jsx("b",{children:"React DevTools"})," is a browser extension that lets you inspect your React component tree, props, state, hooks, performance, and re-renders. It adds two main tabs to your browser DevTools:",e.jsx("b",{children:" Components"})," and ",e.jsx("b",{children:"Profiler"}),"."]}),e.jsxs(n.Section,{children:[e.jsx(n.H2,{children:"What is React DevTools?"}),e.jsxs(n.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Browser extension:"})," Adds React-specific panels to Chrome/Edge/Firefox DevTools. It detects a page running React and lets you inspect it like a native app."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Components tab:"})," Explore the live ",e.jsx("i",{children:"component tree"}),", read props/state, edit values, and see where updates occur."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Profiler tab:"})," Record how long each component render took and why it re-rendered."]})]})]}),e.jsxs(n.Section,{children:[e.jsx(n.H2,{children:"Key Terms (plain English)"}),e.jsxs(n.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Component Tree:"})," The hierarchy of your React components (parents, children, siblings)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Render:"})," When React calls your component function to produce UI (JSX ‚Üí UI)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Re-render:"})," A component renders again because its ",e.jsx("b",{children:"props"}),", ",e.jsx("b",{children:"state"}),", or some",e.jsx("b",{children:"context"})," it uses changed."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Commit phase:"})," The moment React applies computed UI updates to the real DOM."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Memoization:"})," Remembering a previous value so React can skip re-doing work when inputs didn't change (e.g., ",e.jsx(n.InlineCode,{children:"React.memo"}),", ",e.jsx(n.InlineCode,{children:"useMemo"}),",",e.jsx(n.InlineCode,{children:"useCallback"}),")."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Strict Mode (dev only):"})," Helps find side-effects by intentionally double-invoking some lifecycles in development. This can make ‚Äúrenders‚Äù appear twice in DevTools during local development‚Äînormal and expected."]})]})]}),e.jsxs(n.Section,{children:[e.jsx(n.H2,{children:"Install & Open"}),e.jsxs(n.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Install:"})," Add the ‚ÄúReact Developer Tools‚Äù extension from your browser's store (Chrome/Edge/Firefox)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Open:"})," Right-click ‚Üí ",e.jsx("i",{children:"Inspect"})," ‚Üí find the ",e.jsx("b",{children:"Components"})," and ",e.jsx("b",{children:"Profiler"})," tabs near ‚ÄúElements/Console‚Äù."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Vite dev server:"})," Run your app (",e.jsx(n.InlineCode,{children:"npm run dev"}),"). When the extension detects React, the tabs appear automatically."]})]})]}),e.jsxs(n.Section,{children:[e.jsx(n.H2,{children:"Components Tab ‚Äî Inspect Everything"}),e.jsxs(n.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Left pane:"})," The component tree. Click a component to inspect it."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Right pane:"})," Shows ",e.jsx("b",{children:"Props"}),", ",e.jsx("b",{children:"Hooks"})," (state, reducers, refs, memo), and ",e.jsx("b",{children:"Context"}),". You can edit props/state of selected components (where supported) to test UI quickly."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Highlight updates:"})," Toggle the ‚ÄúHighlight updates when components render‚Äù option. React will flash components on screen whenever they re-render."]})]}),e.jsx(n.Pre,{children:`// Example component to see in Components tab
function Counter({ initial = 0 }) {
  const [count, setCount] = React.useState(initial);

  // Try toggling this to observe memoization in action
  const doubled = React.useMemo(() => count * 2, [count]);

  return (
    <div>
      <p>Count: {count} (doubled: {doubled})</p>
      <button onClick={() => setCount(c => c + 1)}>Increment</button>
    </div>
  );
}
Counter.displayName = "CounterDemo"; // shows as this name in DevTools
`}),e.jsxs(n.Small,{children:[e.jsx("b",{children:"Tip:"})," Set ",e.jsx(n.InlineCode,{children:"displayName"})," on components (especially HOCs) so they're easier to find in the tree."]})]}),e.jsxs(n.Section,{children:[e.jsxs(n.H2,{children:["Hooks Panel & ",e.jsx("code",{children:"useDebugValue"})," for Custom Hooks"]}),e.jsxs(n.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Hooks panel:"})," Shows each hook's current value. Great for peeking into"," ",e.jsx(n.InlineCode,{children:"useState"}),", ",e.jsx(n.InlineCode,{children:"useReducer"}),","," ",e.jsx(n.InlineCode,{children:"useMemo"}),", etc."]}),e.jsxs("li",{children:[e.jsx("b",{children:"useDebugValue:"})," Lets custom hooks label their current status/value so DevTools displays a friendly line."]})]}),e.jsx(n.Pre,{children:`// Custom hook with useDebugValue to improve visibility in DevTools
function useToggle(initial = false) {
  const [on, setOn] = React.useState(!!initial);
  const toggle = React.useCallback(() => setOn(v => !v), []);
  React.useDebugValue(on ? "ON" : "OFF"); // shows beside the hook in DevTools
  return [on, toggle];
}

function Bulb() {
  const [on, toggle] = useToggle();
  return (
    <button onClick={toggle} aria-pressed={on}>
      Bulb: {on ? "üí°" : "üí§"}
    </button>
  );
}`}),e.jsxs(n.Small,{children:[e.jsx("b",{children:"Good practice:"})," Add concise labels (like ‚ÄúIDLE/LOADING/SUCCESS/ERROR‚Äù) for async hooks using"," ",e.jsx(n.InlineCode,{children:"useDebugValue"}),"."]})]}),e.jsxs(n.Section,{children:[e.jsx(n.H2,{children:"Profiler Tab ‚Äî Measure Renders"}),e.jsxs(n.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"What it does:"})," Records how long each component render took and ",e.jsx("i",{children:"why"})," it happened (prop change, state change, parent re-render, context update, etc.)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"How to use:"})," Open ",e.jsx("b",{children:"Profiler"})," ‚Üí click ",e.jsx("b",{children:"Start profiling"})," ‚Üí interact with your app ‚Üí click ",e.jsx("b",{children:"Stop profiling"}),". Examine the flame chart and component timings."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Goal:"})," Find ‚Äúhot‚Äù components that re-render often/slowly, then reduce work (memoization, split components, move state down)."]})]}),e.jsx(n.Pre,{children:`// Optional: Wrap parts of your app with React.Profiler to log summary info in console
import { Profiler } from "react";

function onRenderProfiler(
  id,            // the "id" prop of the Profiler tree that has just committed
  phase,         // "mount" or "update"
  actualDuration // time spent rendering the committed update
) {
  console.log("[Profiler]", { id, phase, actualDuration });
}

function App() {
  return (
    <Profiler id="MainArea" onRender={onRenderProfiler}>
      {/* your routes/components here */}
    </Profiler>
  );
}
`}),e.jsxs(n.Small,{children:[e.jsx("b",{children:"Note:"})," The Profiler tab in the extension is usually enough. The"," ",e.jsx(n.InlineCode,{children:"<Profiler>"})," API is optional and useful for custom logging or CI experiments."]})]}),e.jsxs(n.Section,{children:[e.jsx(n.H2,{children:"Typical Debugging Workflow"}),e.jsxs(n.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Step 1:"})," Reproduce the issue in development with your Vite server running."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Step 2:"})," Open ",e.jsx("b",{children:"Components"})," ‚Üí find the component ‚Üí inspect props/state/hooks."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Step 3:"})," Toggle ",e.jsx("b",{children:"Highlight updates"})," and interact to see what re-renders."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Step 4:"})," If it's a performance issue, switch to ",e.jsx("b",{children:"Profiler"})," and record."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Step 5:"})," Apply a fix (state colocation, memoization). Re-profile to confirm improvement."]})]})]}),e.jsxs(n.Section,{children:[e.jsx(n.H2,{children:"Do & Don't"}),e.jsxs(n.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Do"})," name components (",e.jsx(n.InlineCode,{children:"displayName"}),") so they're easy to find."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Do"})," use ",e.jsx(n.InlineCode,{children:"useDebugValue"})," for custom hooks that hold important state."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Do"})," profile before optimizing; measure first, then fix ",e.jsx("i",{children:"specific"})," hot spots."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Don't"})," panic about dev-only double renders under Strict Mode‚Äîit's a feature, not a bug."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Don't"})," over-memoize everything. Memoization has a cost; apply where it reduces meaningful re-renders."]})]})]}),e.jsxs(n.Section,{children:[e.jsx(n.H2,{children:"Troubleshooting"}),e.jsxs(n.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Tabs not showing?"})," Ensure the extension is installed and your app is running a React build (dev server). Reload the page."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Too many renders in dev?"})," Check if Strict Mode is enabled. Double invocations happen only in development."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Slow profile even after fixes?"})," Check large lists, expensive computations, or unnecessary context updates."]})]})]}),e.jsxs(n.Callout,{children:["React DevTools is your X-ray. Use the ",e.jsx("b",{children:"Components"})," tab to understand data flow and the ",e.jsx("b",{children:"Profiler"})," to measure real costs. Name components, label custom hooks, and optimize based on evidence‚Äînot guesses."]})]});export{o as default};
