import{j as e}from"./index-DXTGIo8z.js";import{S as s}from"./styled-jL9hMBcz.js";const t=()=>e.jsxs(s.Page,{children:[e.jsx(s.Title,{children:"Auth Providers (OAuth, OIDC, Social & Enterprise)"}),e.jsxs(s.Lead,{children:["“Auth providers” let users sign in with existing identities (Google, GitHub, Apple, Azure AD, etc.). In React apps, you’ll typically integrate via ",e.jsx("b",{children:"OAuth 2.0"})," and/or ",e.jsx("b",{children:"OpenID Connect (OIDC)"})," on top of a secure backend. This page explains every moving part in plain terms, with code-oriented examples."]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Core Definitions"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Authentication (AuthN):"})," verifying ",e.jsx("i",{children:"who"})," the user is (login)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Authorization (AuthZ):"})," verifying ",e.jsx("i",{children:"what"})," the user can do (permissions)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"OAuth 2.0:"})," a delegation protocol to obtain access tokens for APIs without sharing passwords with the client app."]}),e.jsxs("li",{children:[e.jsx("b",{children:"OpenID Connect (OIDC):"})," an identity layer on top of OAuth 2.0 that adds an ",e.jsx(s.InlineCode,{children:"ID Token"})," (JWT) describing the user."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Identity Provider (IdP):"})," the service that authenticates users (Google, GitHub, Apple, Auth0, Azure AD, Keycloak, etc.)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Client (Relying Party):"})," your app that requests identity and tokens from the IdP."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Redirect URI / Callback URL:"})," where the IdP sends the user back after login."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Scopes:"})," permissions your app requests (e.g., ",e.jsx(s.InlineCode,{children:"openid email profile"}),")."]}),e.jsxs("li",{children:[e.jsx("b",{children:"PKCE (Proof Key for Code Exchange):"})," protects the OAuth code flow in public clients (like SPAs) by binding the code to a one-time secret."]}),e.jsxs("li",{children:[e.jsx("b",{children:"JWT (JSON Web Token):"})," signed token carrying claims (e.g., user id, email, expiry). Used for ID Tokens and often access/refresh tokens."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Session cookie:"})," server-managed login state stored in a cookie; often ",e.jsx("i",{children:"httpOnly"}),", ",e.jsx("i",{children:"secure"}),", and ",e.jsx("i",{children:"SameSite"})," configured."]})]})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Why Use an Auth Provider?"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Less password handling:"})," delegate login to a trusted IdP."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Better UX:"})," one-tap or SSO across many apps."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Security:"})," MFA, device checks, suspicious login detection handled by the IdP."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Standardization:"})," OAuth/OIDC are well-defined, interoperable protocols."]})]})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Typical SPA Flow (Authorization Code + PKCE)"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Step 1:"})," User clicks “Continue with Google”. You redirect to the IdP’s authorize URL with client id, scopes, ",e.jsx("b",{children:"code_challenge"}),", ",e.jsx("b",{children:"state"}),", and ",e.jsx("b",{children:"redirect_uri"}),"."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Step 2:"})," User logs in at the IdP. IdP redirects back to your ",e.jsx("b",{children:"redirect_uri"})," with a one-time ",e.jsx("b",{children:"authorization code"})," and your ",e.jsx("b",{children:"state"})," value."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Step 3:"})," Your ",e.jsx("b",{children:"backend"})," exchanges the code + ",e.jsx("b",{children:"code_verifier"})," for tokens (",e.jsx("b",{children:"ID token"}),", ",e.jsx("b",{children:"access token"}),", optionally ",e.jsx("b",{children:"refresh token"}),")."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Step 4:"})," Backend verifies tokens, creates a secure ",e.jsx("b",{children:"session cookie"})," for the browser, and returns minimal user info to the SPA."]})]}),e.jsx(s.Small,{children:"Why backend? So you can keep secrets off the client, set httpOnly cookies, and control token usage to your APIs."})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Minimal React Wiring (Start & Callback)"}),e.jsx(s.Pre,{children:`// LoginButton.jsx — "Start" auth by navigating to your backend's /auth/start
function LoginButton() {
  const startLogin = () => {
    // Backend builds the authorize URL (with PKCE) and redirects to IdP
    window.location.href = "/api/auth/google/start"; 
  };
  return <button onClick={startLogin}>Continue with Google</button>;
}

// CallbackPage.jsx — receives ?code & ?state on /auth/callback
function CallbackPage() {
  const [status, setStatus] = React.useState("working");

  React.useEffect(() => {
    const params = new URLSearchParams(window.location.search);
    const code = params.get("code");
    const state = params.get("state");
    if (!code) { setStatus("missing code"); return; }

    // Exchange code on the backend; backend sets httpOnly session cookie
    fetch("/api/auth/google/callback?code=" + encodeURIComponent(code) + "&state=" + encodeURIComponent(state), {
      credentials: "include",
    })
      .then(r => r.json())
      .then(() => setStatus("success"))
      .catch(() => setStatus("error"));
  }, []);

  return <p>Login status: {status}</p>;
}`}),e.jsx(s.Small,{children:"The backend handles PKCE and the token exchange. Your SPA just starts the flow and shows result."})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Common Provider Types"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Consumer “social” IdPs:"})," Google, GitHub, Apple, Facebook—quick onboarding and public profiles."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Enterprise IdPs:"})," Azure AD / Entra, Okta, Auth0, Keycloak—SSO, SAML/OIDC, org management."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Passwordless:"})," Magic links or WebAuthn (passkeys) via dedicated providers."]})]})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Sessions, Tokens & Cookies (What to Store Where)"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"ID Token (OIDC):"})," JWT with user identity claims; proves authentication."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Access Token:"})," authorization for API calls; short-lived; scoped."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Refresh Token:"})," long-lived; used by backend to mint new access tokens. ",e.jsx("b",{children:"Rotate"})," and store securely server-side."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Session Cookie:"})," httpOnly + Secure + SameSite; ties the browser to a server-side session; ideal for SPAs to avoid exposing tokens in JS."]})]}),e.jsx(s.Pre,{children:`// Example: call your API with browser session cookie automatically sent
fetch("/api/me", { credentials: "include" })
  .then(r => r.json())
  .then(user => console.log("Current user", user));`})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Security Essentials"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"PKCE:"})," always use with public clients (SPAs, mobile)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"State & nonce:"})," verify on callback to prevent CSRF and replay attacks."]}),e.jsxs("li",{children:[e.jsx("b",{children:"httpOnly cookies:"})," prevent JS access to session; set ",e.jsx(s.InlineCode,{children:"Secure"})," and ",e.jsx(s.InlineCode,{children:"SameSite"})," appropriately."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Callback URL allowlist:"})," only accept redirects to known origins/paths."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Refresh token rotation:"})," rotate and revoke on suspicious use."]}),e.jsxs("li",{children:[e.jsx("b",{children:"CORS:"})," restrict origins; send ",e.jsx(s.InlineCode,{children:'credentials: "include"'})," only when needed."]})]})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"User Linking & Profiles"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Linking:"})," one local user can link multiple providers (e.g., Google + GitHub)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Stable key:"})," prefer the IdP’s stable subject/ID. Email can change."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Profile claims:"})," read ",e.jsx(s.InlineCode,{children:"name"}),", ",e.jsx(s.InlineCode,{children:"email"}),", ",e.jsx(s.InlineCode,{children:"picture"}),"; store only what you need."]})]})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Example: Google & GitHub Side-by-Side"}),e.jsx(s.Pre,{children:`function SocialButtons() {
  return (
    <div className="stack">
      <button onClick={() => (window.location.href = "/api/auth/google/start")}>
        Continue with Google
      </button>
      <button onClick={() => (window.location.href = "/api/auth/github/start")}>
        Continue with GitHub
      </button>
    </div>
  );
}`}),e.jsx(s.Small,{children:"Each backend route builds its own authorize URL and handles its callback."})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Use a Library or Roll Your Own?"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Use a library"})," (e.g., NextAuth.js on Next.js, or server SDKs from your IdP) for speed and fewer mistakes."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Roll your own"})," if you need custom flows, multi-tenant logic, or are not on Next.js. Keep token exchange on the backend."]})]})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Do & Don’t"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Do"})," keep secrets on the server. The SPA should never hold client secrets."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Do"})," store session in httpOnly cookies; avoid putting raw tokens in ",e.jsx(s.InlineCode,{children:"localStorage"}),"."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Do"})," verify ID tokens (signature, issuer, audience) on the backend."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Don’t"})," skip PKCE, state, or nonce—these are not optional."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Don’t"})," accept arbitrary ",e.jsx(s.InlineCode,{children:"redirect_uri"}),"—validate against a allowlist."]})]})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Glossary"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"IdP:"})," Identity Provider; authenticates users and issues tokens."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Relying Party:"})," the app that relies on IdP assertions (your app)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Claim:"})," a piece of info in a token (e.g., ",e.jsx(s.InlineCode,{children:"sub"})," = user id)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Grant:"})," a way to obtain tokens (Authorization Code, Client Credentials, etc.)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"SSO:"})," Single Sign-On—one login across many apps."]}),e.jsxs("li",{children:[e.jsx("b",{children:"SAML:"})," XML-based enterprise SSO standard, often used by older/enterprise IdPs."]})]})]}),e.jsxs(s.Callout,{children:["Summary: in React SPAs, use ",e.jsx("b",{children:"Authorization Code + PKCE"}),", handle exchanges on the ",e.jsx("b",{children:"backend"}),", store login in a secure ",e.jsx("b",{children:"httpOnly session cookie"}),", and rely on standards (OAuth, OIDC). Start simple with Google/GitHub, then add enterprise providers or passwordless as needed."]})]});export{t as default};
