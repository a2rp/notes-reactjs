import{j as e}from"./index-DqLKwkYK.js";import{S as n}from"./styled-Bw6pqD7V.js";const s=()=>e.jsxs(n.Page,{children:[e.jsx(n.Title,{children:"Concurrent Model"}),e.jsxs(n.Lead,{children:["The ",e.jsx("b",{children:"Concurrent Model"})," in React 18+ lets React ",e.jsx("i",{children:"pause, resume, abort, and prioritize"})," rendering work. It makes UIs feel smoother during heavy updates by doing work in small chunks and giving urgent interactions (like typing or clicks) priority over slower, non-urgent UI updates."]}),e.jsxs(n.Section,{children:[e.jsx(n.H2,{children:"What is the Concurrent Model?"}),e.jsxs(n.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Concurrent Rendering:"})," a rendering mode where React can ",e.jsx("em",{children:"interrupt"})," an in-progress render, switch to something more urgent, and come back later. It's still single-threaded JavaScript; React just schedules work more intelligently."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Scheduling:"})," React breaks rendering into small units of work and schedules them based on ",e.jsx("em",{children:"priority"}),"(e.g., user input is higher priority than rendering a huge list)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Non-blocking UI:"})," heavy updates no longer freeze the app; urgent interactions stay responsive."]})]})]}),e.jsxs(n.Section,{children:[e.jsxs(n.H2,{children:["What it is ",e.jsx("i",{children:"not"})]}),e.jsxs(n.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Not multithreading:"})," React does ",e.jsx("em",{children:"not"})," use multiple JS threads. “Concurrent” means smarter scheduling on a single thread."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Not partial commits:"})," React still commits a consistent UI. It won't show half-finished trees; it renders offscreen and then swaps in a complete, consistent result."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Not automatic magic:"})," you still choose which updates are urgent vs. non-urgent (usually via",e.jsx(n.InlineCode,{children:"startTransition"})," or ",e.jsx(n.InlineCode,{children:"useTransition"}),")."]})]})]}),e.jsxs(n.Section,{children:[e.jsx(n.H2,{children:"Key Terms (plain English)"}),e.jsxs(n.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Render Phase:"})," React calculates the next UI tree (pure, no DOM changes yet). This work can be paused or discarded in the concurrent model."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Commit Phase:"})," React applies the final changes to the DOM. This part is ",e.jsx("em",{children:"always"})," synchronous and cannot be interrupted (to keep the UI consistent)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Urgent Update:"})," must feel instant to the user (typing, pressing a button). These run at high priority."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Transition (Non-Urgent Update):"})," updates that can be a bit deferred (e.g., filtering a big list after the user types). Marked with ",e.jsx(n.InlineCode,{children:"startTransition"})," or driven by",e.jsx(n.InlineCode,{children:"useTransition"}),"."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Interruptible Rendering:"})," React can stop work on a heavy render if a more urgent event happens."]})]})]}),e.jsxs(n.Section,{children:[e.jsx(n.H2,{children:"Why does it matter for real apps?"}),e.jsxs(n.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Smoother typing & interactions:"})," avoid UI “freezes” when filtering large lists or switching tabs."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Better perceived performance:"})," React keeps the app interactive even when doing expensive work."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Control over priorities:"})," you can clearly separate “show keystrokes immediately” from “recompute a huge UI.”"]})]})]}),e.jsxs(n.Section,{children:[e.jsx(n.H2,{children:"Minimal mental model: urgent vs. transition"}),e.jsx(n.Pre,{children:`import React from "react";

function SearchPage({ items }) {
  const [query, setQuery] = React.useState("");
  const [list, setList] = React.useState(items);

  // Tell React: updating the big list is non-urgent
  const onChange = (e) => {
    const next = e.target.value;
    setQuery(next); // urgent: the input must update immediately

    // Mark expensive recompute as a transition (non-urgent)
    React.startTransition(() => {
      const lower = next.toLowerCase();
      const filtered = items.filter(it => it.name.toLowerCase().includes(lower));
      setList(filtered);
    });
  };

  return (
    <>
      <input value={query} onChange={onChange} placeholder="Type to filter..." />
      <BigList items={list} />
    </>
  );
}

function BigList({ items }) {
  // Imagine this component is heavy to render
  return items.map(it => <div key={it.id}>{it.name}</div>);
}`}),e.jsxs(n.Small,{children:[e.jsx("b",{children:"Idea:"})," The input updates immediately (urgent). The heavy recompute is marked as a ",e.jsx("i",{children:"transition"}),", so React can keep the app responsive while it prepares the new list in the background."]})]}),e.jsxs(n.Section,{children:[e.jsx(n.H2,{children:"Interrupts without tearing"}),e.jsxs(n.List,{children:[e.jsx("li",{children:"React can pause a render if a new urgent event arrives, do the urgent work, then resume or restart the slow work."}),e.jsx("li",{children:"You won't see mixed states like “old list with new input” mid-commit; React commits a consistent tree."}),e.jsx("li",{children:"Side effects (e.g., DOM mutations in effects) only run after commit, so interrupted renders won't fire effects."})]})]}),e.jsxs(n.Section,{children:[e.jsx(n.H2,{children:"Common patterns that pair well"}),e.jsxs(n.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Transitions:"})," Mark non-urgent state updates. (See the dedicated ",e.jsx("i",{children:"Transitions"})," page.)"]}),e.jsxs("li",{children:[e.jsx("b",{children:"Suspense for Data:"})," Let parts of the tree “wait” for data and show fallbacks without blocking the whole page."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Deferred Values:"})," With ",e.jsx(n.InlineCode,{children:"useDeferredValue"}),", show fresh input now and update heavy UI a moment later."]})]})]}),e.jsxs(n.Section,{children:[e.jsx(n.H2,{children:"Beginner pitfalls & how to avoid them"}),e.jsxs(n.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Doing work in render:"})," heavy calculations in the render phase may be restarted. Move expensive work to",e.jsx(n.InlineCode,{children:"useMemo"})," or mark the resulting update as a transition."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Relying on layout too early:"})," don't read layout during render. Read layout after commit (e.g., in"," ",e.jsx(n.InlineCode,{children:"useLayoutEffect"}),") or via measurement patterns."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Assuming effects run only once:"})," in Strict Mode (dev), React intentionally re-runs some logic to surface bugs. Keep effects idempotent and avoid doing “once-only” work in render."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Misusing transitions:"})," not every update should be a transition. Only mark work that can be delayed without hurting the user experience."]})]})]}),e.jsxs(n.Section,{children:[e.jsx(n.H2,{children:"Testing & mental checks"}),e.jsxs(n.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Does typing feel instant?"})," If not, move the heavy part of the update into a transition."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Is UI consistent during updates?"})," It should never flash half-states at commit."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Are effects idempotent?"})," Effects should tolerate re-runs and mount/unmount during development."]})]})]}),e.jsxs(n.Section,{children:[e.jsx(n.H2,{children:"Glossary"}),e.jsxs(n.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Concurrent Rendering:"})," interruptible rendering mode that prioritizes urgent work."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Transition:"})," a non-urgent update that can be deferred without breaking UX."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Urgent Update:"})," high-priority updates like typing, clicking, or focusing."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Render Phase:"})," React “thinks” about the next UI (can be paused/restarted)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Commit Phase:"})," React “applies” the final UI to the DOM (synchronous)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Suspense Boundary:"})," a component boundary that can show a fallback while data/UI is loading."]})]})]}),e.jsxs(n.Callout,{children:[e.jsx("b",{children:"Summary:"})," The Concurrent Model keeps apps responsive by letting React prioritize urgent work and defer heavy updates. Learn to tag non-urgent updates as transitions and pair concurrency with Suspense and deferred values for smooth, beginner-friendly UX."]})]});export{s as default};
