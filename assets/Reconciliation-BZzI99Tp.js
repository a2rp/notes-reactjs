import{j as e}from"./index-QA-tBXdP.js";import{S as s}from"./styled-CdpBflK6.js";const t=()=>e.jsxs(s.Page,{children:[e.jsx(s.Title,{children:"Reconciliation"}),e.jsxs(s.Lead,{children:["Reconciliation is React's process of comparing the previous UI tree with the next one and applying the minimal DOM changes. Keys and element identity determine whether parts of the tree are ",e.jsx("b",{children:"updated"})," or",e.jsx("b",{children:" remounted"}),"."]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Definition"}),e.jsxs(s.List,{children:[e.jsx("li",{children:"React keeps a previous “virtual” tree. On state/prop changes, a new tree is produced."}),e.jsx("li",{children:"React diffs both trees to decide: update a node in place, move it, insert a new one, or remove it."}),e.jsxs("li",{children:["Decisions are local and fast (heuristics) → performance is generally ",e.jsx("b",{children:"O(n)"})," per list of siblings."]})]})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"How nodes are matched"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Same type → update"}),": For DOM elements (e.g., ",e.jsx(s.InlineCode,{children:"<div/>"}),"), React updates attributes and keeps the underlying node. For components (e.g., ",e.jsx(s.InlineCode,{children:"<Card/>"}),"), React calls the function again with new props."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Different type → remount"}),": Changing ",e.jsx(s.InlineCode,{children:"<div>"})," to ",e.jsx(s.InlineCode,{children:"<span>"}),", or ",e.jsx(s.InlineCode,{children:"<Card/>"})," to ",e.jsx(s.InlineCode,{children:"<Profile/>"}),", unmounts the old subtree and mounts a new one (local state lost)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Text nodes"})," update when the string changes; they remount if replaced by a different element type."]})]}),e.jsx(s.Pre,{children:`// Same type: patch in place
<div title="A" />   // prev
<div title="B" />   // next → updates title only

// Different type: remount subtree
<div />             // prev
<span />            // next → <div> removed, <span> created`})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Keys control identity among siblings"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:["Keys are compared only among ",e.jsx("b",{children:"siblings"}),". They tell React which item is which across renders."]}),e.jsxs("li",{children:["With correct keys, React can ",e.jsx("b",{children:"move"})," nodes instead of destroying and recreating them."]}),e.jsx("li",{children:"Missing/unstable keys (e.g., array index) cause mismatches: state jumps rows, focus is lost, inputs reset."})]}),e.jsx(s.Pre,{children:`// Good: stable IDs
const rows = data.map(item => <Row key={item.id} item={item} />);

// Bad: index as key (reorder/filter/insert will break identity)
const rows = data.map((item, i) => <Row key={i} item={item} />);`})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Re-render vs Remount"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Re-render:"})," the component function runs again to produce new JSX; local state and refs are preserved as long as identity (type + key) is the same."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Remount:"})," the old instance unmounts and a new one mounts; local state, DOM state, and refs are reset."]})]}),e.jsx(s.Pre,{children:`// Same identity → re-render (state preserved)
<Card key={user.id} user={user} />

// Different identity → remount (state reset)
<Card key={user.id} />  →  <Profile key={user.id} />    // type changed
<Card key={v1} />       →  <Card key={v2} />            // key changed`}),e.jsxs(s.Small,{children:["Changing ",e.jsx(s.InlineCode,{children:"key"})," is the standard way to intentionally force a remount."]})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Tree-shape pitfalls (accidental remounts)"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Wrapper type changes:"})," toggling between ",e.jsx(s.InlineCode,{children:"<div>"})," and ",e.jsx(s.InlineCode,{children:"<section>"})," remounts children."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Moving nodes across parents:"})," if an item's parent changes, React may recreate it unless keys and structure allow a move."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Conditional wrappers:"})," adding/removing an extra wrapper element changes type/position → remount and state loss."]})]}),e.jsx(s.Pre,{children:`// ❌ Wrapper type toggles cause remounts
{asSection ? <section><List /></section> : <div><List /></div>}

// ✅ Keep type stable; toggle role/class instead
<section aria-label={label} className={cls}>
  <List />
</section>`})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Lists: preserving state during insert/remove/reorder"}),e.jsxs(s.List,{children:[e.jsx("li",{children:"Use a stable, unique key per item (DB id, slug). Avoid index keys when items can move."}),e.jsxs("li",{children:["Keep item-local state ",e.jsx("b",{children:"inside"})," the keyed component so identity sticks with the data."]}),e.jsx("li",{children:"When transforming arrays (filter, sort, splice), return new arrays (immutable updates)."})]}),e.jsx(s.Pre,{children:`function Row({ item }) {
  const [text, setText] = React.useState(item.name); // preserved when key is stable
  return <input value={text} onChange={e => setText(e.target.value)} />;
}

{items.map(item => <Row key={item.id} item={item} />)}`})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Inputs: controlled vs uncontrolled and remounts"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Controlled"})," inputs store value in React state; remount resets state unless lifted."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Uncontrolled"})," inputs hold value in the DOM; remount clears DOM value."]}),e.jsx("li",{children:"Preserve identity where input state must survive; remount only when a reset is intended."})]})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"When children update"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:["A parent re-render normally re-renders children (render ≠ DOM change). Use ",e.jsx(s.InlineCode,{children:"React.memo"})," for pure children that can skip renders when props are equal."]}),e.jsx("li",{children:"Context updates re-render all consumers below the provider."}),e.jsx("li",{children:"Re-rendering is cheap; avoid premature micro-optimizations—optimize hotspots found via Profiler."})]}),e.jsx(s.Pre,{children:`const Row = React.memo(function Row({ item }) {
  // renders only when 'item' prop changes by shallow compare
  return <li>{item.name}</li>;
});`})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Forcing a remount (when needed)"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:["Change the ",e.jsx(s.InlineCode,{children:"key"})," to reset component state (e.g., reset a form after submit)."]}),e.jsx("li",{children:"Use sparingly—most resets can be handled by updating state."})]}),e.jsx(s.Pre,{children:`// Reset form by bumping key
<Form key={formVersion} initial={defaults} />`})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Performance notes"}),e.jsxs(s.List,{children:[e.jsx("li",{children:"Keep component types stable across states; prefer toggling props/classes to swapping tags."}),e.jsx("li",{children:"Use stable keys for lists to avoid unnecessary remounts and state loss."}),e.jsx("li",{children:"Extract heavy computations outside render; memoize derived values when they're expensive."}),e.jsx("li",{children:"For very long lists, use virtualization; reconciliation then operates on a small visible window."})]})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Do / Don't"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Do"})," keep element types stable across conditional branches when possible."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Do"})," use stable keys (IDs) for lists; place the key on the element returned by ",e.jsx(s.InlineCode,{children:"map"}),"."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Do"})," localize state inside the keyed component so identity travels with the data item."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Don't"})," use array index as a key for dynamic lists (reorder/insert/remove)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Don't"})," switch wrapper types casually; it triggers remounts and loses state/focus."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Don't"})," over-optimize renders without profiling—optimize the hotspots first."]})]})]}),e.jsx(s.Callout,{children:"Summary: reconciliation preserves nodes when type and key are stable, and remounts when identity changes. Stable keys and consistent tree shapes keep state and focus where they belong, while enabling React to update only what changed."})]});export{t as default};
