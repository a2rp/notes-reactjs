import{j as e}from"./index-CDxhzYTb.js";import{S as s}from"./styled-BK5KYTPH.js";const i=()=>e.jsxs(s.Page,{children:[e.jsx(s.Title,{children:"SSR vs SSG vs ISR"}),e.jsxs(s.Lead,{children:["Modern React apps can render pages at ",e.jsx("b",{children:"build time"}),", at ",e.jsx("b",{children:"request time"}),", or a mix of both with",e.jsx("b",{children:" revalidation"}),". Understanding these modes helps you pick the right strategy for ",e.jsx("i",{children:"speed"}),", ",e.jsx("i",{children:"SEO"}),", and ",e.jsx("i",{children:"freshness"}),"."]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Baseline: CSR (Client-Side Rendering)"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Definition:"})," The server sends a minimal HTML shell + JS bundle. The browser runs JS to fetch data and render UI."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Implication:"})," Fast deploys, simple hosting. Initial HTML is sparse → slower first content if networks are slow."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Use when:"})," Auth-heavy dashboards, apps with mostly private data, or SEO is not a priority."]})]})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"SSR - Server-Side Rendering"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Definition:"})," HTML is generated ",e.jsx("em",{children:"per request"})," on the server, then sent to the browser. The browser ",e.jsx("b",{children:"hydrates"})," it (attaches event handlers) to make it interactive."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Request time:"})," Fresh data every request by default (can still cache)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Performance:"})," Better ",e.jsx("b",{children:"TTFB"})," than CSR for content pages; data fetching happens on the server close to databases."]}),e.jsxs("li",{children:[e.jsx("b",{children:"SEO:"})," Full HTML at response time helps crawlers."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Costs:"})," Server work on every request; careful with caching for scale."]})]}),e.jsx(s.Pre,{children:`// Next.js (Pages Router) - SSR
export async function getServerSideProps(ctx) {
  const data = await fetch("https://api.example.com/items").then(r => r.json());
  return { props: { data } };
}
export default function Page({ data }) {
  return <ul>{data.map(it => <li key={it.id}>{it.name}</li>)}</ul>;
}`})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"SSG - Static Site Generation"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Definition:"})," HTML is generated ",e.jsx("em",{children:"at build time"}),". Files are pushed to a CDN; no server compute is needed per request."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Build time:"})," Data is fetched during the build. Output is a static file."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Performance:"})," Excellent ",e.jsx("b",{children:"TTFB"}),", ",e.jsx("b",{children:"FCP"}),", ",e.jsx("b",{children:"LCP"})," via CDN."]}),e.jsxs("li",{children:[e.jsx("b",{children:"SEO:"})," Great (full HTML), but data is as fresh as the last build."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Costs:"})," Build times can grow if you pre-render many pages; content updates require a rebuild (unless using ISR)."]})]}),e.jsx(s.Pre,{children:`// Next.js (Pages Router) - SSG
export async function getStaticProps() {
  const data = await fetch("https://api.example.com/blog").then(r => r.json());
  return { props: { data } }; // Static at build time
}
export default function Blog({ data }) {
  return <div>{data.map(p => <article key={p.slug}>{p.title}</article>)}</div>;
}`})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"ISR - Incremental Static Regeneration"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Definition:"})," Start with ",e.jsx("b",{children:"SSG"}),", then ",e.jsx("b",{children:"re-generate"})," pages in the background at a configured interval. Visitors get static speed, content updates automatically."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Revalidation:"})," A TTL (e.g., 60 seconds) or tag-based invalidation triggers a background rebuild for the next request."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Staleness model:"})," Users may see slightly ",e.jsx("em",{children:"stale"})," content until regeneration completes (",e.jsx("i",{children:"stale-while-revalidate"})," pattern)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Use when:"})," Mostly-static content that updates periodically (blogs, docs, catalogs)."]})]}),e.jsx(s.Pre,{children:`// Next.js (Pages Router) - ISR with revalidate
export async function getStaticProps() {
  const data = await fetch("https://api.example.com/news").then(r => r.json());
  return { props: { data }, revalidate: 60 }; // re-gen in background at most every 60s
}

// Next.js (App Router) - ISR (segment-level)
export const revalidate = 60;
export default async function Page() {
  const data = await fetch("https://api.example.com/news", { next: { revalidate: 60 }})
                .then(r => r.json());
  return <div>{data.items.map(n => <p key={n.id}>{n.title}</p>)}</div>;
}`}),e.jsxs(s.Small,{children:["App Router also supports ",e.jsx(s.InlineCode,{children:"dynamic"})," and ",e.jsx(s.InlineCode,{children:"cache"})," controls:",e.jsx(s.Pre,{children:`export const dynamic = "force-static";  // always static
// or
export const dynamic = "force-dynamic"; // always server-render per request
// fetch(url, { cache: "force-cache" | "no-store" })`})]})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Which one should I choose?"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Marketing / Docs / Blog:"})," SSG → add ISR if content updates often."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Product listing with frequent updates:"})," ISR (fast + periodic freshness)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Per-user dashboards / highly personalized:"})," SSR (or CSR) - content depends on cookies/session."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Search pages with many filters:"})," SSR if SEO matters; CSR if SEO isn't critical."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Massive catalogs:"})," Hybrid - SSG core pages, ISR detail pages, SSR for search facets."]})]})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Performance & SEO considerations"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Hydration:"})," After SSR/SSG/ISR, the browser attaches JS to server-rendered HTML to make it interactive."]}),e.jsxs("li",{children:[e.jsx("b",{children:"TTFB / FCP / LCP:"})," SSG/ISR often win via CDN. SSR performance depends on server time and caching."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Critical HTML:"})," Put above-the-fold content in the server render for SEO and fast paint; defer non-critical JS."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Caching:"})," Use HTTP cache headers/CDN. With SSR, consider cache keys that vary by ",e.jsx("i",{children:"user/session"})," when needed."]})]})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Common pitfalls"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:'"SSR automatically fixes SEO":'})," If real data still loads on the client after paint, crawlers may not see it. Render important content on the server."]}),e.jsxs("li",{children:[e.jsx("b",{children:'"ISR for user-specific data":'})," Don't. ISR output is shared; use SSR/CSR for private pages."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Unbounded builds with SSG:"})," Pre-rendering tens of thousands of pages can bloat build time. Use ISR or on-demand generation."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Cache blindness:"})," For SSR, forgeting to vary cache by cookie/locale can leak content. Design cache keys carefully."]})]})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"At a glance - minimal examples"}),e.jsx(s.Pre,{children:`// SSR (Pages Router)
export async function getServerSideProps() { /* fetch per request */ return { props: { data: [] } }; }

// SSG (Pages Router)
export async function getStaticProps() { /* fetch at build */ return { props: { data: [] } }; }

// ISR (Pages Router)
export async function getStaticProps() { return { props: { data: [] }, revalidate: 120 }; }

// ISR (App Router)
export const revalidate = 120;
export default async function Page() {
  const data = await fetch(url, { next: { revalidate: 120 }}).then(r => r.json());
  return <pre>{JSON.stringify(data, null, 2)}</pre>;
}`})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Glossary"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Build time:"})," When your CI/CD generates static HTML before deployment."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Request time:"})," When the server renders HTML for each incoming HTTP request."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Hydration:"})," The browser attaching React event handlers to server-rendered HTML."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Revalidation (ISR):"})," Regenerating a static page after a TTL or on demand, typically in the background."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Stale-while-revalidate:"})," Serve a cached (possibly stale) page while re-generation happens."]}),e.jsxs("li",{children:[e.jsx("b",{children:"TTFB/FCP/LCP:"})," Response and paint metrics; lower is better for perceived speed."]}),e.jsxs("li",{children:[e.jsx("b",{children:"CDN:"})," Edge network that serves static assets close to users for low latency."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Personalization:"})," Content that varies by user (session/cookies/headers). Avoid caching across users."]})]})]}),e.jsxs(s.Callout,{children:["Summary: ",e.jsx("b",{children:"SSR"})," = fresh per request, great for personalized or frequently changing pages."," ",e.jsx("b",{children:"SSG"})," = static at build, best performance for stable content."," ",e.jsx("b",{children:"ISR"})," = static speed with scheduled freshness. Mix them as needed per route."]})]});export{i as default};
