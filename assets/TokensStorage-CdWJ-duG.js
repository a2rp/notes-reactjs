import{j as e}from"./index-CDxhzYTb.js";import{S as s}from"./styled-CLaFcxL7.js";const r=()=>e.jsxs(s.Page,{children:[e.jsx(s.Title,{children:"Tokens Storage"}),e.jsxs(s.Lead,{children:[e.jsx("b",{children:"Token storage"})," = how your frontend keeps credentials (usually short-lived"," ",e.jsx(s.InlineCode,{children:"access tokens"})," and long-lived"," ",e.jsx(s.InlineCode,{children:"refresh tokens"}),") so it can call protected APIs securely. The goal is to ",e.jsx("b",{children:"minimize exposure"})," to ",e.jsx("i",{children:"XSS"})," and ",e.jsx("i",{children:"CSRF"})," while keeping UX smooth."]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Glossary (clear definitions)"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Access token:"})," short-lived credential presented to APIs (often a string or JWT) via",e.jsx(s.InlineCode,{children:"Authorization: Bearer <token>"}),"."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Refresh token:"})," longer-lived credential used ",e.jsx("i",{children:"only"})," to obtain new access tokens. Should not be exposed to JS when possible."]}),e.jsxs("li",{children:[e.jsx("b",{children:"JWT (JSON Web Token):"})," compact string with ",e.jsx("i",{children:"header"}),", ",e.jsx("i",{children:"payload (claims)"}),", and"," ",e.jsx("i",{children:"signature"}),". Verifiable by the API without a DB lookup. Signed, not encrypted."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Bearer token:"})," any party holding the token is treated as the user. If leaked, it can be used until it expires or is revoked."]}),e.jsxs("li",{children:[e.jsx("b",{children:"XSS (Cross-Site Scripting):"})," attacker runs JS in your page. If tokens live in"," ",e.jsx(s.InlineCode,{children:"localStorage"})," or variables, they may be stolen."]}),e.jsxs("li",{children:[e.jsx("b",{children:"CSRF (Cross-Site Request Forgery):"})," browser auto-sends cookies on cross-site requests. An attacker site can trigger a user’s cookies unless you defend (SameSite/CSRF tokens)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"HttpOnly cookie:"})," cookie not readable from JS (",e.jsx(s.InlineCode,{children:"document.cookie"}),"). Helps against XSS stealing the value."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Secure cookie:"})," cookie only sent over HTTPS."]}),e.jsxs("li",{children:[e.jsx("b",{children:"SameSite"})," cookie attribute: governs cross-site sending:"," ",e.jsx(s.InlineCode,{children:"Lax"})," (default, safe for most),"," ",e.jsx(s.InlineCode,{children:"Strict"})," (safest, may break some flows),"," ",e.jsx(s.InlineCode,{children:"None"})," (allows cross-site; must be Secure)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"CORS:"})," browser protection controlling which origins can read responses. Doesn’t protect against CSRF by itself."]})]})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Storage options (and risks)"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"In-memory (JS variable/state):"})," disappears on refresh. ",e.jsx("i",{children:"Best for access tokens"}),"—not readable by other tabs, reduces persistence if XSS occurs (attacker must be present “now”)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"HttpOnly cookies:"})," not readable by JS; auto-sent to the server. Good place for"," ",e.jsx("i",{children:"refresh tokens"})," or server sessions. Must handle CSRF (SameSite/CSRF token)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"localStorage / sessionStorage:"})," simple, but ",e.jsx("i",{children:"readable by JS"}),". If XSS happens, tokens can be exfiltrated. Avoid for long-lived secrets (refresh tokens)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"IndexedDB:"})," also JS-readable; similar XSS risk profile."]})]}),e.jsxs(s.Callout,{children:["Rule of thumb: ",e.jsx("b",{children:"Access token in memory"}),", ",e.jsx("b",{children:"Refresh token in HttpOnly cookie"}),", or use"," ",e.jsx("b",{children:"cookie-based session"})," (no tokens in JS at all)."]})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Pattern A — Memory access token + HttpOnly refresh cookie"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:["On login, server sets ",e.jsx("b",{children:"refresh"})," token cookie (",e.jsx(s.InlineCode,{children:"HttpOnly; Secure; SameSite=Lax"}),") and returns a short-lived"," ",e.jsx("b",{children:"access"})," token in the JSON response."]}),e.jsxs("li",{children:["Client keeps the access token ",e.jsx("i",{children:"only in memory"}),". When it expires (401), call"," ",e.jsx(s.InlineCode,{children:"/auth/refresh"}),"—the browser sends the refresh cookie automatically; server returns a new access token."]}),e.jsx("li",{children:"Logout = clear memory token + call server to invalidate refresh cookie (server clears cookie / rotates server-side state)."})]}),e.jsx(s.Pre,{children:`// Minimal example: centralized fetch wrapper (no libraries)
let accessToken = null; // in-memory only

export function setAccessToken(t) { accessToken = t; }
export function clearAccessToken() { accessToken = null; }

async function refreshAccessToken() {
  // Sends refresh cookie automatically; server replies with a fresh access token
  const res = await fetch("/auth/refresh", { method: "POST", credentials: "include" });
  if (!res.ok) throw new Error("Refresh failed");
  const data = await res.json();
  setAccessToken(data.accessToken);
  return data.accessToken;
}

export async function apiFetch(input, init = {}) {
  const headers = new Headers(init.headers || {});
  if (accessToken) headers.set("Authorization", "Bearer " + accessToken);

  const res = await fetch(input, { ...init, headers, credentials: "include" });

  if (res.status !== 401) return res;

  // Attempt a one-time refresh then retry:
  const newToken = await refreshAccessToken();
  const retryHeaders = new Headers(init.headers || {});
  retryHeaders.set("Authorization", "Bearer " + newToken);
  return fetch(input, { ...init, headers: retryHeaders, credentials: "include" });
}
`}),e.jsx(s.Small,{children:"Notes: handle concurrency (queue 401s while one refresh is in flight), rotate refresh tokens on each use, and keep access tokens short-lived (e.g., 5–15 minutes)."})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Pattern B — Cookie-only session (no tokens in JS)"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:["Server issues a ",e.jsx("b",{children:"session cookie"})," (",e.jsx(s.InlineCode,{children:"HttpOnly; Secure; SameSite=Lax"}),"). Client never sees a token; it just calls APIs, and the cookie authenticates."]}),e.jsxs("li",{children:["Must defend against ",e.jsx("b",{children:"CSRF"}),": use ",e.jsx(s.InlineCode,{children:"SameSite=Lax/Strict"})," and/or"," ",e.jsx("b",{children:"CSRF tokens"})," (double-submit or stateful token on server)."]})]}),e.jsx(s.Pre,{children:`// Example CSRF pattern (double-submit cookie):
// 1) Server sets 'csrf' cookie (readable by JS).
// 2) Client reads 'csrf' cookie and sends it back in a header with each state-changing request.
// 3) Server validates cookie value == header value.

async function postWithCsrf(url, body) {
  const csrf = document.cookie
    .split("; ")
    .find(c => c.startsWith("csrf="))
    ?.split("=")[1];

  const res = await fetch(url, {
    method: "POST",
    credentials: "include",
    headers: { "Content-Type": "application/json", "x-csrf": csrf || "" },
    body: JSON.stringify(body),
  });
  return res;
}
`}),e.jsxs(s.Small,{children:["Where possible, prefer ",e.jsx("b",{children:"SameSite=Lax"})," + CSRF token on state-changing requests (POST/PUT/PATCH/DELETE)."]})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Do & Don’t"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Do"})," keep access tokens short-lived; refresh silently when needed."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Do"})," store refresh tokens in ",e.jsx("b",{children:"HttpOnly"})," cookies (not readable by JS)."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Do"})," use ",e.jsx(s.InlineCode,{children:"Secure"})," cookies and HTTPS everywhere."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Do"})," set ",e.jsx(s.InlineCode,{children:"SameSite=Lax"})," or"," ",e.jsx(s.InlineCode,{children:"Strict"})," on auth cookies to reduce CSRF."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Do"})," rotate refresh tokens; revoke on logout or suspicion."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Don’t"})," put long-lived refresh tokens in ",e.jsx(s.InlineCode,{children:"localStorage"}),"."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Don’t"})," expose secrets (API keys) in frontend code; those belong on the server."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Don’t"})," rely on CORS alone for CSRF protection—CORS is about who can ",e.jsx("i",{children:"read"})," responses."]})]})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Common pitfalls & fixes"}),e.jsxs(s.List,{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Storing tokens where XSS can read them:"})," prefer memory or HttpOnly cookies; fix XSS by sanitizing user content and using a strict CSP."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Unbounded token lifetimes:"})," set expiry, rotate refresh tokens, implement server-side revocation."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Insecure cookie attributes:"})," always set ",e.jsx(s.InlineCode,{children:"Secure"}),","," ",e.jsx(s.InlineCode,{children:"HttpOnly"}),", and a safe ",e.jsx(s.InlineCode,{children:"SameSite"}),"."]}),e.jsxs("li",{children:[e.jsx("b",{children:"No CSRF defense with cookies:"})," use SameSite and CSRF tokens for state-changing routes."]})]})]}),e.jsxs(s.Section,{children:[e.jsx(s.H2,{children:"Implementation checklist"}),e.jsxs(s.List,{children:[e.jsx("li",{children:"Access token in memory (or cookie-only session)."}),e.jsx("li",{children:"Refresh token in HttpOnly Secure cookie (SameSite=Lax/Strict)."}),e.jsx("li",{children:"Short access token TTL; refresh endpoint that rotates refresh tokens."}),e.jsx("li",{children:"CSRF protection for cookie-authenticated writes."}),e.jsx("li",{children:"Logout clears access token in memory and invalidates cookie on server."}),e.jsx("li",{children:"Handle retry race conditions (single refresh in flight; queue 401s)."}),e.jsx("li",{children:"Monitor for token replay anomalies; add IP/device checks if appropriate."})]})]}),e.jsxs(s.Callout,{children:["Summary: keep the ",e.jsx("b",{children:"blast radius"})," small. Use ",e.jsx("i",{children:"memory"})," for access tokens, ",e.jsx("i",{children:"HttpOnly cookies"})," for refresh/session, short expiries, rotation, and explicit CSRF defenses. Simpler is safer."]})]});export{r as default};
